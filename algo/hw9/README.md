# Деревья поиска - 2

## A. Сбалансированное двоичное дерево поиска

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 512 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Реализуйте сбалансированное двоичное дерево поиска.

### Входные данные

Входной файл содержит описание операций с деревом, их количество не превышает 10^5. В каждой строке находится одна из следующих операций:

* insert _x_ — добавить в дерево ключ _x_. Если ключxесть в дереве, то ничего делать не надо

* delete _x_ — удалить из дерева ключ _x_. Если ключаxв дереве нет, то ничего делать не надо

* exists _x_ — если ключ _x_ есть в дереве выведите «true», если нет «false»

* next _x_ — выведите минимальный элемент в дереве, строго больший _x_, или «none» если такого
нет

* prev _x_ — выведите максимальный элемент в дереве, строго меньший _x_, или «none» если такого
нет

В дерево помещаются и извлекаются только целые числа, не превышающие по модулю 10^9.

### Выходные данные

Выведите последовательно результат выполнения всех операций exists,next,prev. Следуйте
формату выходного файла из примера.

### Пример

**Входные данные**
```
insert 2
insert 5
insert 3
exists 2
exists 4
next 4
prev 4
delete 5
next 4
prev 4
```

**Выходные данные**
```
true
false
5
3
none
3
```

### [Решение](taskA.py)

## B. Неявный ключ

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Научитесь быстро делать две операции с массивом:

* add _i_ _x_ — добавить после _i_-го элемента _x_ (0 ≤ _i_ ≤ _n_)

* del _i_ — удалить _i_-й элемент (1 ≤ _i_ ≤ _n_)

### Входные данные

На первой строке _n0_ и _m_ (1 ≤ _n0_, _m_ ≤ 10^5) — длина исходного массива и количество запросов.
На второй строке _n0_ целых чисел от 0 до 10^9 - 1 — исходный массив.
Далее _m_ строк, содержащие запросы.
Гарантируется, что запросы корректны: например, если просят удалить _i_-й элемент, он точно есть.

### Выходные данные

Выведите конечное состояние массива. На первой строке количество элементов, на второй строке сам массив.

### Пример

**Входные данные**
```
3 4
1 2 3
del 3
add 0 9
add 3 8
del 2
```

**Выходные данные**
```
3
9 2 8
```

### [Решение](taskB.py)

## C. Переместить в начало

Ограничение по времени на тест: 6 секунд

Ограничение по памяти на тест: 512 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Вам дан массив _a1_ = 1, _a2_ = 2, ..., _an_ = _n_ и последовальность операций:
переместить элементы с _li_ по _ri_ в начало массива.
Например, для массива 2, 3, 6, 1, 5, 4, после операции (2, 4) новый порядок будет 3, 6, 1, 2, 5, 4.
А после применения операции (3, 4) порядок элементов в массиве будет 1, 2, 3, 6, 5, 4.

### Входные данные

В первой строке входного файла указаны числа _n_ и _m_ (2 ≤ _n_ ≤ 100 000, 1 ≤ _m_ ≤ 100 000) — число элементов
в массиве и число операций. Следующие _m_ строк содержат операции в виде двух целых чисел: _li_ и _ri_ (1 ≤ _li_ ≤ _ri_ ≤ _n_).

### Выходные данные

Выведите _n_ целых чисел — порядок элементов в массиве после применения всех операций.

### Пример

**Входные данные**
```
6 3
2 4
3 5
2 2
```

**Выходные данные**
```
1 4 5 2 3 6
```

### [Решение](taskC.py)

## D. Развороты

Ограничение по времени на тест: 1 секунда

Ограничение по памяти на тест: 512 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Вам дан массив _a1_ = 1, _a2_ = 2, ..., _an_ = _n_ и последовальность операций:
переставить элементы с _li_ по _ri_ в обратном порядке. Например, для массива 1, 2, 3, 4, 5, после
операции (2, 4) новый порядок будет 1, 4, 3, 2, 5. А после применения операции (3, 5) порядок элементов
в массиве будет 1, 4, 5, 2, 3.

### Входные данные

В первой строке входного файла указаны числа _n_ и _m_ (2 ≤ _n_ ≤ 100 000, 1 ≤ _m_ ≤ 100 000) — число элементов
в массиве и число операций. Следующие _m_ строк содержат операции в виде двух целых чисел: _li_ и _ri_ (1 ≤ _li_ ≤ _ri_ ≤ _n_).

### Выходные данные

Выведите _n_ целых чисел — порядок элементов в массиве после применения всех операций.

### Пример

**Входные данные**
```
5 3
2 4
3 5
2 2
```

**Выходные данные**
```
1 4 5 2 3
```

### [Решение](taskD.py)
