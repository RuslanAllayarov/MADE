# Графы-1. Поиск в глубину и его друзья

## A. Компоненты связности

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Дан неориентированный граф. Требуется выделить компоненты связности в нем.

### Входные данные

Первая строка входного файла содержит два натуральных числа _n_ и _m_ — количество вершин и ребер графа
соответственно (1 ≤ _n_ ≤ 100 000, 0 ≤ _m_ ≤200 000).

Следующие _m_ строк содержат описание ребер по одному на строке. Ребро номер _i_ описывается двумя
натуральными числами _bi_, _ei_ — номерами концов ребра (1 ≤ _bi,ei_ ≤ _n_). Допускаются петли и параллельные ребра.

### Выходные данные

В первой строке выходного файла выведите целое число _k_ — количество компонент связности графа. Во второй
строке выведите _n_ натуральных чисел _a1,a1,…,an_, не превосходящих _k_, где _ai_ — номер компоненты
связности, которой принадлежит _i_-я вершина.

### Примеры

**Входные данные**
```
3 1
1 2
```

**Выходные данные**
```
2
1 1 2
```

**Входные данные**
```
4 2
1 3
2 4
```

**Выходные данные**
```
2
1 2 1 2
```

### [Решение](taskA.py)

## B. Репосты

Ограничение по времени на тест: 1 секунда

Ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Однажды Поликарп опубликовал в социальной сети смешную картинку с опросом про цвет своего хэндла. Многие из
его друзей стали репостить шутку Поликарпа себе в ленту. Некоторые из них репостили репосты и так далее.

Эти события заданы в виде последовательности строк «_name1_ reposted _name2_» где _name1_ — это имя того, кто
репостнул, а _name2_ — имя того, с чей ленты репостнули шутку. Гарантируется, что для каждой строки
«_name1_ reposted _name2_» пользователь «_name1_» еще не имел эту шутку в свой ленте, а «_name2_» уже имел ее
в своей ленте к моменту репоста. Поликарп зарегистрирован под именем «Polycarp», и изначально шутка есть только
в его ленте.

Поликарп измеряет успешность шутки как длину наибольшей цепочки репостов. Выведите успешность шутки Поликарпа.

### Входные данные

В первой строке входных данных записано целое число _n_ (1 ≤ _n_ ≤ 200) — количество репостов. Далее записаны
сами репосты в порядке их совершения. Каждый из них записан в отдельной строке и имеет вид «_name1_ reposted _name2_».
Все имена во входных данных состоят из прописных или строчных латинских букв и/или цифр и имеют длины от 2 до 24
символов включительно.

Известно, что имена пользователей регистронезависимы, то есть два имени, отличающиеся исключительно регистром
букв, соответствуют одному и тому же пользователю соцсети.

### Выходные данные

Выведите единственное целое число — максимальную длину цепочки репостов.

### Примеры

**Входные данные**
```
5
tourist reposted Polycarp
Petr reposted Tourist
WJMZBMR reposted Petr
sdya reposted wjmzbmr
vepifanov reposted sdya
```

**Выходные данные**
```
6
```

**Входные данные**
```
6
Mike reposted Polycarp
Max reposted Polycarp
EveryOne reposted Polycarp
111 reposted Polycarp
VkCup reposted Polycarp
Codeforces reposted Polycarp
```

**Выходные данные**
```
2
```

**Входные данные**
```
1
SoMeStRaNgEgUe reposted PoLyCaRp
```

**Выходные данные**
```
2
```

### [Решение](taskB.py)

## C. Топологическая сортировка

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Дан ориентированный невзвешенный граф. Необходимо построить его топологическую сортирвоку.

### Входные данные

В первой строке входного файла даны два натуральных числа _n_ и _m_ (1≤ _n_ ≤100 000, 0≤ _m_ ≤100 000) — число
вершин и рёбер в графе соответственно. Далее в _m_ строках перечислены рёбра графа. Каждое ребро задаётся парой
чисел — номерами начальной и конечной вершин соответственно.

### Выходные данные

Выведите любую топологическую сортировку графа в виде последовательности номеров вершин. Если граф невозможно
топологически отсортировать, выведите −1.

### Пример

**Входные данные**
```
6 6
1 2
3 2
4 2
2 5
6 5
4 6
```

**Выходные данные**
```
4 6 3 1 2 5
```

### [Решение](taskC.py)

## D. Конденсация графа

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Конденсацией графа _G_ называется новый граф _H_, где каждой компоненте сильной связности в графе _G_ соответствует
вершина из графа _H_. Ребро _vu_ в графе _H_ есть тогда и только тогда, когда в графе _G_ существует хотя бы одно
ребро из соответствующей _v_ компоненте сильной связности, в компоненту, соответствующую _u_.

Требуется найти количество ребер в конденсации ориентированного графа.

Примечание: конденсация графа не содержит кратных ребер.

### Входные данные

Первая строка входного файла содержит два натуральных числа _n_ и _m_ — количество вершин и ребер графа
соответственно (_n_ ≤10 000, _m_ ≤100 000). Следующие _m_ строк содержат описание ребер, по одному на строке.
Ребро номер _i_ описывается двумя натуральными числами _bi, ei_ — началом и концом ребра соответственно
(1 ≤ _bi, ei_ ≤ _n_). В графе могут присутствовать кратные ребра и петли.

### Выходные данные

Единственная строка выходного файла должна содержать одно число — количество ребер в конденсации графа.

### Пример

**Входные данные**
```
4 4
2 1
3 2
2 3
4 3
```

**Выходные данные**
```
2
```

### [Решение](taskD.py)

## E. Конденсация графа

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Дан неориентированный граф. Требуется найти все точки сочленения в нём.

### Входные данные

Первая строка входного файла содержит два натуральных числа _n_ и _m_ — количество вершин и ребер графа
соответственно (1⩽ _n_ ⩽20 000, 1⩽ _m_ ⩽200 000).

Следующие _m_ строк содержат описание ребер, по одному на строке.
Ребро номер _i_ описывается двумя натуральными числами _bi, ei_ — началом и концом ребра соответственно
(1 ≤ _bi, ei_ ≤ _n_).

### Выходные данные

Первая строка выходного файла должна содержать одно натуральное число _b_ — количество точек сочленения в
заданном графе. На следующей строке выведите _b_ целых чисел — номера вершин, которые являются точками
сочленения, в возрастающем порядке. 

### Пример

**Входные данные**
```
6 7
1 2
2 3
2 4
2 5
4 5
1 3
3 6
```

**Выходные данные**
```
2
2 3
```

### [Решение](taskE.py)
