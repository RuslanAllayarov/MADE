# Сортировки и О-нотация

## A. Излишне простая сортировка

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 64 мегабайта

ввод: стандартный ввод

вывод: стандартный вывод

Дан небольшой массив целых чисел. Ваша задача — отсортировать его в порядке неубывания.

### Входные данные

В первой строке входного файла содержится число _N_ (1 ≤ _N_ ≤ 1000) — количество элементов в массиве. Во второй строке находятся _N_ целых чисел, по модулю не превосходящих 10^9.

### Выходные данные

В выходной файл надо вывести этот же массив в порядке неубывания, между любыми двумя числами должен стоять ровно один пробел.

### Пример

**Входные данные**
```
10
1 8 2 1 4 7 3 2 3 6
```

**Выходные данные**
```
1 1 2 2 3 3 4 6 7 8 
```

### Примечание

Запрещается использовать стандартные сортировки.

### [Решение](taskA.py)

## B. Простая сортировка

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 64 мегабайта

ввод: стандартный ввод

вывод: стандартный вывод

Дан массив целых чисел. Ваша задача — отсортировать его в порядке неубывания.

### Входные данные

В первой строке входного файла содержится число _N_ (1 ≤ _N_ ≤ 100 000) — количество элементов в массиве. Во второй строке находятся _N_ целых чисел, по модулю не превосходящих 10^9.

### Выходные данные

В выходной файл надо вывести этот же массив в порядке неубывания, между любыми двумя числами должен стоять ровно один пробел.

### Пример

**Входные данные**
```
10
1 8 2 1 4 7 3 2 3 6
```

**Выходные данные**
```
1 1 2 2 3 3 4 6 7 8 
```

### Примечание

Запрещается использовать стандартные сортировки.

### [Решение](taskB.py)

## C. Количество инверсий

Ограничение по времени на тест: 5 секунд

Ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Напишите программу, которая для заданного массива _A_ = ⟨_a1_,_a2_,…,_an_⟩ находит количество пар (_i_,_j_) таких, что _i_ < _j_ и _ai_ > _aj_.

### Входные данные

Первая строка входного файла содержит натуральное число _n_ (1 ≤ _n_ ≤ 500 000) — количество элементов массива. Вторая строка содержит _n_ попарно различных элементов массива _A_ (0 ≤ _ai_ ≤ 10^6).

### Выходные данные

В выходной файл выведите одно число — ответ на задачу.

### Примеры

**Входные данные**
```
4
1 2 4 5
```

**Выходные данные**
```
0
```

**Входные данные**
```
4
5 4 2 1
```

**Выходные данные**
```
6
```

### [Решение](taskC.py)

## D. Простая сортировка

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 64 мегабайта

ввод: стандартный ввод

вывод: стандартный вывод

Дан массив целых чисел. Ваша задача — отсортировать его в порядке неубывания.

### Входные данные

В первой строке входного файла содержится число _N_ (1 ≤ _N_ ≤ 100 000) — количество элементов в массиве. Во второй строке находятся _N_ целых чисел, по модулю не превосходящих 10^9.

### Выходные данные

В выходной файл надо вывести этот же массив в порядке неубывания, между любыми двумя числами должен стоять ровно один пробел.

### Пример

**Входные данные**
```
10
1 8 2 1 4 7 3 2 3 6
```

**Выходные данные**
```
1 1 2 2 3 3 4 6 7 8 
```

### Примечание

Запрещается использовать стандартные сортировки.

### [Решение](taskD.py)

## E. Королевская сортировка

Ограничение по времени на тест: 1 секунда

Ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

  У нерушимого города-государства Иннолэнд богатая история. Множество королей правило на
этой земле в течение многих веков. Город гордится своими предводителями, поэтому его жители
хотят выбить имя каждого из королей на особой плите в самом центре города (дабы заполнить хоть
чем-то пустующий и безлюдный город).

  У каждого короля Иннолэнда помимо имени имеется порядковый номер. Этот номер записан в
римской системе счисления рядом с именем каждого короля великого города-государства. Например, _Louis XIII_ был тринадцатым королем Иннолэнда, имеющим имя _Louis_ (ох уж эти иннолэндовцы и их имена...).

  Однако не все так просто устроено в этом городе. Жители Иннолэнда любят соблюдать порядок
во всем, поэтому должен соблюдаться и порядок имен на плите. Важно, чтобы имена на плите были
упорядочены в лексикографическом порядке. Однако некоторые короли могли иметь одно и то же
имя, поэтому короли с одинаковым именем они должны быть отсортированы в соответствии с их
порядковыми номерами. Например, славный король _Louis IX_ должен быть указан на плите после
доблестного короля _Louis VIII_.

  Жители Иннолэнда пока ещё плохо ладят с упорядочиванием имен и уж тем более с компью-
терами, поэтому они обратились за помощью к Вам - Вы-то уже давно хорошо знакомы с этими
вещами. Они передали список имен всех королей, а Вы должны вернуть им тот же список, но имена в нем должны идти уже в нужном порядке: в желаемом списке раньше записаны те короли, у
которых имя лексикографически меньше, а среди королей с одинаковым именем раньше идут те, у
которых меньше порядковый номер.

### Входные данные

В первой строке записано число _n_ (1 ≤ _n_ ≤ 50) - количество королей.
В следующих _n_ строках записаны имена и порядковые номера королей. В каждой строке сначала
записано имя короля, состоящее из не более чем 20 латинских букв (первая буква имени прописная,
все последующие строчные), а затем через пробел записан его порядковый номер в виде римского
числа от 1 до 50.

### Выходные данные

В _n_ строках должны быть записаны имена и порядковые числа королей, упорядоченные необходимым образом

### Пример

**Входные данные**
```
2
Louis IX
Louis VIII
```

**Выходные данные**
```
Louis VIII
Louis IX 
```

**Входные данные**
```
2
Louis IX
Philippe II
```

**Выходные данные**
```
Louis IX
Philippe II 
```

**Входные данные**
```
2
Philippe II
Philip II
```

**Выходные данные**
```
Philip II
Philippe II
```

### Примечание

Числа от 1 до 10 обозначаются с помощью римских цифр как _I_, _II_, _III_, _IV_, _V_, _VI_, _VII_, _VIII_,
_IX_ и _X_ соответственно;

Числа 20, 30, 40 и 50 обозначаются как _XX_, _XXX_, _XL_ и _L_ соответственно;

Остальные двузначные числа меньшие 50 в римской записи могут быть получены путем
конкатенации римской записи десятков и римской записи единиц этого числа. Например,
47 = 40 + 7 = «_XL_» + «_VII_» = «_XLVII_».

### [Решение](taskE.py)
