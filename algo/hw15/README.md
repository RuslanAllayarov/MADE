# Грамматики и парсинг

## A. Разделение выражения на лексемы

Ограничение по времени на тест: 1 секунда

Ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Задано числовое выражение, заканчивающееся точкой. Необходимо разбить его на лексемы и вывести каждую на новой
строке. Гарантируется, что исходное выражение корректно.

В выражении могут встречаться знаки сложения, вычитания, умножения и скобки. Приоритет операций стандартный.
Все числа в выражении целые и принадлежат диапазону LongInt.

### Входные данные

Первая строка содержит заданное выражение. Его длина не превосходит 100 знаков. Гарантируется, что выражение
заканчивается точкой.

### Выходные данные

Выведите все встречающиеся лексемы выражения по порядку и ровно по одной на каждой строке.

### Пример

**Входные данные**
```
1+(2*2-3).
```

**Выходные данные**
```
1
+
(
2
*
2
-
3
)
```

### [Решение](taskA.py)

## B. Значение выражения

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 64 мегабайта

ввод: стандартный ввод

вывод: стандартный вывод

Задано числовое выражение, заканчивающееся точкой. Необходимо посчитать его значение или сказать, что оно
содержит ошибку. В выражении могут встречаться знаки сложения, вычитания, умножения и скобки. Приоритет операций
стандартный. Все числа в выражении целые и принадлежат диапазону LongInt. Также гарантируется, что все
промежуточные вычисления умещаются в этот тип. Унарный плюс и унарный минус в выражении встречаться не могут,
как и два знака подряд.

### Входные данные

Первая строка содержит заданное выражение. Его длина не превосходит 100 знаков. Гарантируется, что выражение
заканчивается точкой.

### Выходные данные

Выведите значение этого выражения или слово «WRONG», если значение не определено.

### Примеры

**Входные данные**
```
1+(2*2-3).
```

**Выходные данные**
```
2
```

**Входные данные**
```
1+a+1.
```

**Выходные данные**
```
WRONG
```

### [Решение](taskB.py)

## C. Новогоднее выражение

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 64 мегабайта

ввод: стандартный ввод

вывод: стандартный вывод

Задано новогоднее выражение, заканчивающееся точкой. Необходимо посчитать его значение или сказать, что оно
содержит ошибку. В новогоднем выражении могут встречаться знаки сложения, вычитания, умножения и скобки,
константы Ded Moroz, Moroz и Snegurochka, а также вызов функции Podarok, которая принимает одно число на вход
и возвращает его, увеличенное на 5, если оно было положительно, или возвращает его модуль, если оно было меньше
либо равно 0. Приоритет операций стандартный. Все числа в выражении целые и принадлежат диапазону LongInt.
Также гарантируется, что все промежуточные вычисления умещаются в этот тип.

### Входные данные

Первая строка содержит заданное выражение. Его длина не превосходит 200 знаков. Гарантируется, что выражение
заканчивается точкой.

Значения констант:
Ded Moroz	2020
Moroz	 -30
Snegurochka	10

### Выходные данные

Выведите значение этого новогоднего выражения или слово «WRONG», если значение не определено.

### Примеры

**Входные данные**
```
Podarok(Moroz-Ded Moroz)*2.
```

**Выходные данные**
```
4100
```

**Входные данные**
```
Snegurochka-30.
```

**Выходные данные**
```
-20
```

### [Решение](taskC.py)

## D. Chaotic Evil

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайта

ввод: стандартный ввод

вывод: стандартный вывод

Рассмотрим язык, чуть более похожий на Си, чем в прошлый раз. В нём есть следующие простые типы:

Имя типа	Размер
bool	1 байт
char или signed char	1 байт
unsigned char	1 байт
short, signed short, short int или signed short int	2 байта
unsigned short или unsigned short int	2 байта
int, signed или signed int	4 байта
unsigned или unsigned int	4 байта
long, signed long, long int или signed long int	8 байт
unsigned long или unsigned long int	8 байт
long long, signed long long, long long int или signed long long int	8 байт
unsigned long long или unsigned long long int	8 байт

В языке есть оператор sizeof, который позволяет узнать размер любого типа в байтах. К примеру,
sizeof(int) равен четырём.

В языке есть оператор alignof, который позволяет узнать выравнивание любого типа в байтах.
Адрес переменной какого-то типа T в памяти должен делиться на alignof(T). sizeof(T) всегда делится на
alignof(T). alignof(T) всегда является неотрицательной целой степенью двойки. Для простых
типов, alignof(T) == sizeof(T).

В языке есть массивы фиксированной длины, состоящие из элементов одного типа. Массив из n элементов, каждый
типа T обозначается как T[n]. sizeof(T[n]) равен sizeof(T) * n. К примеру, sizeof(short[13]) равен 26, так как
размер типа short — два байта, а в массиве 13 элементов. alignof(T[n]) равен alignof(T). Поддержки многомерных
массивов в языке нет.

В языке есть структуры — композитные типы, позволяющие объединять фиксированное количество переменных (полей)
разных типов в одну. Пусть в структуре n > 0 полей f1, ..., fn типов T1, ..., Tn. Пусть эта структура лежит
в памяти по адресу a. Тогда должны выполняться следующие дополнительные условия:

- Адрес f1 равен a.
- Для k = 2, ..., n, Адрес fk больше адреса fk - 1.
- Поля не могут пересекаться
- Как и для самой структуры, так и для всех её полей должны выполнятся стандартные правила выравнивания.
- Выравнивание структуры — максимум из выравниваний её полей.
- Размер структуры не меньше суммы размеров её полей.
- Размер структуры — минимальный из размеров, удовлетворяющий всем условиям. 

Вам предлагается написать программу, вычисляющую sizeof и alignof для произвольных типов.

### Входные данные

Во вводе записаны команды, typedef, sizeof или alignof.

Команда typedef объявляет новый тип. Например, typedef eightbytes unsigned char[8] объявляет новый тип
eightbytes, который представляет собой массив из восьми unsigned char. typedef может также объявлять
структуры. Смотрите примеры. Гарантируется, что имя нового типа — непустая строка из латинских букв длиной
не более 32 символов, кроме bool, char, signed, unsigned, short, int, long, struct, typedef, sizeof, alignof

Гарантируется, что объявления новых типов имеют уникальные имена.

Команды sizeof и alignof печатают на экран на новой строке размер и выравнивание типа соответственно. Например,
sizeof unsigned char[8] напечатает на экран 8.

Гарантируется, что размер входных данных по объёму не превосходит одного мегабайта. Размер каждого используемого
типа не превосходит одного эксабайта.

### Выходные данные

Для каждой команды sizeof или alignof в отдельной строке напечатайте результат выполнения
соответствующего оператора.

### Примеры

**Входные данные**
```
typedef eightbytes unsigned char[8]
sizeof eightbytes
alignof eightbytes
```

**Выходные данные**
```
8
1
```

**Входные данные**
```
typedef verylong struct {
long[2];
unsigned short int[4];
}
sizeof verylong
alignof verylong
```

**Выходные данные**
```
24
8
```

**Входные данные**
```
typedef verylong struct {
long[2];
unsigned short int[4];
}
typedef evenlonger struct {
verylong[4];
}
sizeof evenlonger
alignof evenlonger
typedef arr evenlonger[123]
sizeof arr
alignof arr
```

**Выходные данные**
```
96
8
11808
8
```

### [Решение](taskD.py)
