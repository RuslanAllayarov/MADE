# Деревья поиска - 1

## A. Простое двоичное дерево поиска

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 512 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Реализуйте просто двоичное дерево поиска.

### Входные данные

Входной файл содержит описание операций с деревом, их количество не превышает 100. В каждой строке находится одна из следующих операций:

* insert _x_ — добавить в дерево ключ _x_. Если ключxесть в дереве, то ничего делать не надо

* delete _x_ — удалить из дерева ключ _x_. Если ключаxв дереве нет, то ничего делать не надо

* exists _x_ — если ключ _x_ есть в дереве выведите «true», если нет «false»

* next _x_ — выведите минимальный элемент в дереве, строго больший _x_, или «none» если такого
нет

* prev _x_ — выведите максимальный элемент в дереве, строго меньший _x_, или «none» если такого
нет

В дерево помещаются и извлекаются только целые числа, не превышающие по модулю 10^9.

### Выходные данные

Выведите последовательно результат выполнения всех операций exists,next,prev. Следуйте
формату выходного файла из примера.

### Пример

**Входные данные**
```
insert 2
insert 5
insert 3
exists 2
exists 4
next 4
prev 4
delete 5
next 4
prev 4
```

**Выходные данные**
```
true
false
5
3
none
3
```

### [Решение](taskA.py)

## B. Сбалансированное двоичное дерево поиска

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 512 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Реализуйте сбалансированное двоичное дерево поиска.

### Входные данные

Входной файл содержит описание операций с деревом, их количество не превышает 10^5. В каждой строке находится одна из следующих операций:

* insert _x_ — добавить в дерево ключ _x_. Если ключxесть в дереве, то ничего делать не надо

* delete _x_ — удалить из дерева ключ _x_. Если ключаxв дереве нет, то ничего делать не надо

* exists _x_ — если ключ _x_ есть в дереве выведите «true», если нет «false»

* next _x_ — выведите минимальный элемент в дереве, строго больший _x_, или «none» если такого
нет

* prev _x_ — выведите максимальный элемент в дереве, строго меньший _x_, или «none» если такого
нет

В дерево помещаются и извлекаются только целые числа, не превышающие по модулю 10^9.

### Выходные данные

Выведите последовательно результат выполнения всех операций exists,next,prev. Следуйте
формату выходного файла из примера.

### Пример

**Входные данные**
```
insert 2
insert 5
insert 3
exists 2
exists 4
next 4
prev 4
delete 5
next 4
prev 4
```

**Выходные данные**
```
true
false
5
3
none
3
```

### [Решение](taskB.py)

# C. K-й максимум

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 512 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Напишите программу, реализующую структуру данных, позволяющую добавлять и удалять элементы, а также находить _k_-й максимум.

### Входные данные

Первая строка входного файла содержит натуральное число _n_ — количество команд
(_n_ ⩽ 100 000). Последующие _n_ строк содержат по одной команде каждая. Команда записывается в
виде двух чисел _ci_ и _ki_ — тип и аргумент команды соответственно (|_ki_| ⩽ 10^9 ). Поддерживаемые
команды:

* +1 (или просто 1 ): Добавить элемент с ключом _ki_.

* 0 : Найти и вывести _ki_-й максимум.

* -1 : Удалить элемент с ключом _ki_.

Гарантируется, что в процессе работы в структуре не требуется хранить элементы с равными
ключами или удалять несуществующие элементы. Также гарантируется, что при запросе _ki_-го максимума, он существует.

### Выходные данные

Для каждой команды нулевого типа в выходной файл должна быть выведена строка, содержащая единственное число — _ki_-й максимум.

### Пример

**Входные данные**
```
11
+1 5
+1 3
+1 7
0 1
0 2
0 3
-1 5
+1 10
0 1
0 2
0 3
```

**Выходные данные**
```
7
5
3
10
7
3
```

### [Решение](taskC.py)

# D. И снова сумма

Ограничение по времени на тест: 3 секунды

Ограничение по памяти на тест: 512 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Реализуйте структуру данных, которая поддерживает множество _S_ целых чисел, с котором разрешается производить следующие операции:

* add(_i_)— добавить в множество _S_ число _i_ (если он там уже есть, то множество не меняется);

* sum(_l_, _r_) — вывести сумму всех элементов _x_ из _S_, которые удовлетворяют неравенству
_l_ ⩽ _x_ ⩽ _r_.

### Входные данные

Исходно множество _S_ пусто. Первая строка входного файла содержит _n_ — количество операций
( 1 ⩽ _n_ ⩽ 300 000).Следующие _n_ строк содержат операции. Каждая операция имеет вид либо «+_i_»,
либо «? _l_ _r_». Операция «? _l_ _r_» задает запрос sum(_l_, _r_).
Если операция « +_i_ » идет во входном файле в начале или после другой операции «+», то она
задает операцию add(_i_). Если же она идет после запроса «?», и результат этого запроса был _y_, то
выполняется операция add((_i_ + _y_) mod 10^9 ).
Во всех запросах и операциях добавления параметры лежат в интервале от 0 до 10^9.

### Выходные данные

Для каждого запроса выведите одно число — ответ на запрос.

### Пример

**Входные данные**
```
6
+ 1
+ 3
+ 3
? 2 4
+ 1
? 2 4
```

**Выходные данные**
```
3
7
```

### [Решение](taskD.py)
