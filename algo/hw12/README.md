# Графы-3. Остовные дереья и СНМ

## A. Система непересекающихся множеств

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Реализуйте систему непересекающихся множеств. Вместе с каждым множеством храните минимальный, максимальный элемент в этом
множестве и их количество.

### Входные данные

Первая строка входного файла содержит _n_ — количество элементов в носителе (1 ≤ _n_ ≤ 300 000). Далее операций с
множеством. Операция get должна возвращать минимальный, максимальный элемент в соответствующем множестве, а также
их количество.

### Выходные данные

Выведите последовательно результат выполнения всех операций get.

### Пример

**Входные данные**
```
5
union 1 2
get 3
get 2
union 2 3
get 2
union 1 3
get 5
union 4 5
get 5
union 4 1
get 5
```

**Выходные данные**
```
3 3 1
1 2 2
1 3 3
5 5 1
4 5 2
1 5 5
```

### [Решение](taskA.py)

## B. Подсчет опыта

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 64 мегабайта

ввод: стандартный ввод

вывод: стандартный вывод

В очередной онлайн игре игроки, как обычно, сражаются с монстрами и набирают опыт. Для того, чтобы сражаться с
монстрами, они объединяются в кланы. После победы над монстром, всем участникам клана, победившего его,
добавляется одинаковое число единиц опыта. Особенностью этой игры является то, что кланы никогда не распадаются
и из клана нельзя выйти. Единственная доступная операция — объединение двух кланов в один.

Поскольку игроков стало уже много, вам поручили написать систему учета текущего опыта игроков.

### Входные данные

В первой строке входного файла содержатся числа _n_ (1 ≤ _n_ ≤ 200000) и _m_ (1 ≤ _m_ ≤ 200000) — число
зарегистрированных игроков и число запросов.

В следующих _m_ строках содержатся описания запросов. Запросы бывают трех типов:

- join _X Y_ — объединить кланы, в которые входят игроки _X_ и _Y_ (если они уже в одном клане, то ничего не меняется).
- add _X V_ — добавить _V_ единиц опыта всем участникам клана, в который входит игрок _X_ (1 ≤ _V_ ≤ 100).
- get _X_ — вывести текущий опыт игрока _X_. 

Изначально у всех игроков 0 опыта и каждый из них состоит в клане, состоящим из него одного.

### Выходные данные

Для каждого запроса get _X_ выведите текущий опыт игрока _X_.

### Пример

**Входные данные**
```
3 6
add 1 100
join 1 3
add 1 50
get 1
get 2
get 3
```

**Выходные данные**
```
150
0
50
```

### [Решение](taskB.py)

## C. Остовное дерево

Ограничение по времени на тест: 4 секунды

Ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Даны точки на плоскости, являющиеся вершинами полного графа. Вес ребра равен расстоянию между точками,
соответствующими концам этого ребра. Требуется в этом графе найти остовное дерево минимального веса.

### Входные данные

Первая строка входного файла содержит натуральное число _n_ — количество вершин графа (1≤ _n_ ≤10000). Каждая из
следующих n строк содержит два целых числа _xi, yi_  — координаты _i_-й вершины (−10000≤ _xi,yi_ ≤10000). Никакие
две точки не совпадают.

### Выходные данные

Первая строка выходного файла должна содержать одно вещественное число — вес минимального остовного дерева.

### Пример

**Входные данные**
```
2
0 0
1 1
```

**Выходные данные**
```
1.4142135624
```

### [Решение](taskC.py)

## D. Остовное дерево 2

Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Требуется найти в связном графе остовное дерево минимального веса.

### Входные данные

Первая строка входного файла содержит два натуральных числа _n_ и _m_ — количество вершин и ребер графа
соответственно. Следующие _m_ строк содержат описание ребер по одному на строке. Ребро номер _i_ описывается
тремя натуральными числами _bi, ei_ и _wi_ — номера концов ребра и его вес соответственно
(1≤ _bi,ei_ ≤ _n_ , 0≤ _wi_ ≤100000). _n_ ≤200000, _m_ ≤200000.

Граф является связным.

### Выходные данные

Первая строка выходного файла должна содержать одно натуральное число — вес минимального остовного дерева.

### Пример

**Входные данные**
```
4 4
1 2 1
2 3 2
3 4 5
4 1 4
```

**Выходные данные**
```
7
```

### [Решение](taskD.py)

## E. Минимальное дерево путей

Ограничение по времени на тест: 6 секунд

Ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Вам дан взвешенный ориентированный граф, содержащий _n_ вершин и _m_ рёбер. Найдите минимально возможную сумму
весов _n−1_ ребра, которые нужно оставить в графе, чтобы из вершины с номером 1 по этим ребрам можно было добраться
до любой другой вершины.

### Входные данные

В первой строке даны два целых числа _n_ и _m_ (1≤ _n_ ≤1000, 0≤ _m_ ≤10000) — количество вершин и ребер в графе.

В следующих _m_ строках даны ребра графа. Ребро описывается тройкой чисел _ai, bi_ и _wi_
(1≤ _ai,bi _≤ _n_ ; −10^9≤ _wi_ ≤10^9) — номер вершины, из которой исходит ребро, номер вершины, в которую входит
ребро, и вес ребра.

### Выходные данные

Если нельзя оставить подмножество ребер так, чтобы из вершины с номером 1 можно было добраться до любой другой,
в единственной строке выведите «NO».

Иначе, в первой строке выведите «YES», а во второй строке выведите минимальную возможную сумму весов ребер,
которых необходимо оставить.

### Примеры

**Входные данные**
```
2 1
2 1 10
```

**Выходные данные**
```
NO
```

**Входные данные**
```
4 5
1 2 2
1 3 3
1 4 3
2 3 2
2 4 2
```

**Выходные данные**
```
YES
6
```

### [Решение](taskE.py)
